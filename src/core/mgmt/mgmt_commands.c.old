#include "mgmt_commands.h"
#include "mgmt_config.h"
#include "core/config.h"
#include "core/server.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <ctype.h>

/**
 * Management Command Implementation
 *
 * All commands use session's pre-allocated buffers.
 * No dynamic allocation - memory-safe by design.
 */

/* Command handler function pointer */
typedef int (*cmd_handler_t)(mgmt_session_t *session, int argc, char **argv);

/* Command dispatch entry */
typedef struct {
    const char *name;
    cmd_handler_t handler;
    const char *help;
} cmd_entry_t;

/* Forward declarations */
static int cmd_help(mgmt_session_t *session, int argc, char **argv);
static int cmd_show(mgmt_session_t *session, int argc, char **argv);
static int cmd_set(mgmt_session_t *session, int argc, char **argv);
static int cmd_get(mgmt_session_t *session, int argc, char **argv);
static int cmd_pending(mgmt_session_t *session, int argc, char **argv);
static int cmd_clear(mgmt_session_t *session, int argc, char **argv);
static int cmd_validate(mgmt_session_t *session, int argc, char **argv);
static int cmd_restart(mgmt_session_t *session, int argc, char **argv);
static int cmd_quit(mgmt_session_t *session, int argc, char **argv);
static int cmd_shutdown(mgmt_session_t *session, int argc, char **argv);

/* Command dispatch table */
static const cmd_entry_t commands[] = {
    {"help",     cmd_help,     "Display available commands"},
    {"show",     cmd_show,     "Display status/config/clients"},
    {"set",      cmd_set,      "Set configuration parameter"},
    {"get",      cmd_get,      "Get configuration parameter"},
    {"pending",  cmd_pending,  "Show pending changes"},
    {"clear",    cmd_clear,    "Clear pending changes"},
    {"validate", cmd_validate, "Validate pending config"},
    {"restart",  cmd_restart,  "Apply changes and restart"},
    {"quit",     cmd_quit,     "Close session"},
    {"shutdown", cmd_shutdown, "Shutdown application"},
    {NULL, NULL, NULL}
};

/* Helper: Send string to session (uses write_buffer for formatting if needed) */
static void send_str(mgmt_session_t *session, const char *str) {
    write(session->socket_fd, str, strlen(str));
}

/* Helper: Send formatted string (uses write_buffer) */
static void send_fmt(mgmt_session_t *session, const char *fmt, ...) {
    va_list args;
    int len;

    va_start(args, fmt);
    len = vsnprintf(session->write_buffer, MGMT_BUFFER_SIZE, fmt, args);
    va_end(args);

    if (len > 0 && len < MGMT_BUFFER_SIZE) {
        write(session->socket_fd, session->write_buffer, len);
    }
}

/* Helper: Parse command line into argc/argv (modifies read_buffer in place) */
static int parse_command(char *line, int *argc, char **argv, int max_args) {
    int count = 0;
    char *p = line;

    while (*p && count < max_args) {
        /* Skip whitespace */
        while (*p && isspace((unsigned char)*p)) {
            p++;
        }

        if (*p == '\0') {
            break;
        }

        /* Start of argument */
        argv[count++] = p;

        /* Find end of argument */
        while (*p && !isspace((unsigned char)*p)) {
            p++;
        }

        if (*p) {
            *p++ = '\0';
        }
    }

    *argc = count;
    return count;
}

/**
 * mgmt_command_loop - Main command processing loop
 */
void mgmt_command_loop(mgmt_session_t *session) {
    ssize_t bytes_read;
    char *newline;
    int argc;
    char *argv[16];  /* Stack allocation for argv pointers */
    int i;
    int found;
    const char *prompt = "xoe> ";

    while (1) {
        /* Send prompt */
        send_str(session, prompt);

        /* Read command line (into pre-allocated buffer) */
        bytes_read = read(session->socket_fd, session->read_buffer,
                         MGMT_BUFFER_SIZE - 1);
        if (bytes_read <= 0) {
            break;  /* Connection closed or error */
        }

        session->read_buffer[bytes_read] = '\0';

        /* Strip newlines */
        newline = strchr(session->read_buffer, '\n');
        if (newline) *newline = '\0';
        newline = strchr(session->read_buffer, '\r');
        if (newline) *newline = '\0';

        /* Skip empty lines */
        if (session->read_buffer[0] == '\0') {
            continue;
        }

        /* Parse command */
        parse_command(session->read_buffer, &argc, argv, 16);
        if (argc == 0) {
            continue;
        }

        /* Dispatch command */
        found = 0;
        for (i = 0; commands[i].name != NULL; i++) {
            if (strcmp(argv[0], commands[i].name) == 0) {
                if (commands[i].handler(session, argc, argv) != 0) {
                    return;  /* Command requested exit */
                }
                found = 1;
                break;
            }
        }

        if (!found) {
            send_fmt(session, "Unknown command: %s (type 'help' for list)\n",
                    argv[0]);
        }
    }
}

/**
 * cmd_help - Display help
 */
static int cmd_help(mgmt_session_t *session, int argc, char **argv) {
    int i;
    (void)argc;
    (void)argv;

    send_str(session, "\nAvailable Commands:\n");
    for (i = 0; commands[i].name != NULL; i++) {
        send_fmt(session, "  %-12s - %s\n", commands[i].name, commands[i].help);
    }
    send_str(session, "\n");

    return 0;
}

/**
 * cmd_show - Show status/config/clients
 */
static int cmd_show(mgmt_session_t *session, int argc, char **argv) {
    xoe_config_t cfg;

    if (argc < 2) {
        send_str(session, "Usage: show {config|status|clients}\n");
        return 0;
    }

    if (strcmp(argv[1], "config") == 0) {
        /* Show active configuration */
        if (g_config_manager == NULL) {
            send_str(session, "Error: Config manager not initialized\n");
            return 0;
        }

        mgmt_config_get_active(g_config_manager, &cfg);

        send_str(session, "\n=== Active Configuration ===\n");
        send_fmt(session, "Mode:         %s\n",
                cfg.mode == MODE_SERVER ? "server" :
                cfg.mode == MODE_CLIENT ? "client" : "unknown");
        send_fmt(session, "Server Port:  %d\n", cfg.port);
        send_fmt(session, "Listen IP:    %s\n",
                cfg.listen_addr ? cfg.listen_addr : "0.0.0.0");
        send_fmt(session, "Connect Addr: %s\n",
                cfg.connect_address ? cfg.connect_address : "(none)");
        send_fmt(session, "Mgmt Port:    %d\n", cfg.mgmt_port);
#if TLS_ENABLED
        send_fmt(session, "TLS:          %s\n",
                cfg.tls_enabled ? "enabled" : "disabled");
        if (cfg.tls_enabled) {
            send_fmt(session, "  Cert:       %s\n",
                    cfg.tls_cert_path ? cfg.tls_cert_path : "(none)");
            send_fmt(session, "  Key:        %s\n",
                    cfg.tls_key_path ? cfg.tls_key_path : "(none)");
        }
#endif
        if (cfg.serial_config != NULL) {
            send_fmt(session, "Serial:       %s @ %d baud\n",
                    cfg.serial_config->device_path,
                    cfg.serial_config->baud_rate);
        }
        send_str(session, "\n");

    } else if (strcmp(argv[1], "status") == 0) {
        /* Show server status */
        int clients = get_active_client_count();
        int has_pending = 0;

        if (g_config_manager != NULL) {
            has_pending = mgmt_config_has_pending(g_config_manager);
        }

        send_str(session, "\n=== Server Status ===\n");
        send_fmt(session, "Active Clients: %d\n", clients);
        send_fmt(session, "Pending Changes: %s\n",
                has_pending ? "yes" : "no");
        send_fmt(session, "Restart Flag: %s\n",
                g_mgmt_restart_requested ? "SET" : "clear");
        send_str(session, "\n");

    } else if (strcmp(argv[1], "clients") == 0) {
        /* Show connected clients */
        int clients = get_active_client_count();
        send_str(session, "\n=== Connected Clients ===\n");
        send_fmt(session, "Active Connections: %d\n", clients);
        send_str(session, "(Detailed client list not yet implemented)\n\n");

    } else {
        send_fmt(session, "Unknown show target: %s\n", argv[1]);
    }

    return 0;
}

/**
 * cmd_set - Set configuration parameter
 */
static int cmd_set(mgmt_session_t *session, int argc, char **argv) {
    const char *param;
    const char *value;

    if (argc < 3) {
        send_str(session, "Usage: set <parameter> <value>\n");
        send_str(session, "Parameters:\n");
        send_str(session, "  mode <server|client>\n");
        send_str(session, "  port <number>\n");
        send_str(session, "  listen_addr <ip>\n");
        send_str(session, "  connect_addr <ip:port>\n");
        send_str(session, "  mgmt_port <number>\n");
#if TLS_ENABLED
        send_str(session, "  tls <on|off>\n");
        send_str(session, "  tls_cert <path>\n");
        send_str(session, "  tls_key <path>\n");
#endif
        return 0;
    }

    if (g_config_manager == NULL) {
        send_str(session, "Error: Config manager not initialized\n");
        return 0;
    }

    param = argv[1];
    value = argv[2];

    if (strcmp(param, "mode") == 0) {
        xoe_mode_t mode;
        if (strcmp(value, "server") == 0) {
            mode = MODE_SERVER;
        } else if (strcmp(value, "client") == 0) {
            mode = MODE_CLIENT;
        } else {
            send_fmt(session, "Invalid mode: %s (use 'server' or 'client')\n", value);
            return 0;
        }
        mgmt_config_set_mode(g_config_manager, mode);
        send_fmt(session, "Pending: mode = %s\n", value);

    } else if (strcmp(param, "port") == 0) {
        int port = atoi(value);
        if (port <= 0 || port > 65535) {
            send_str(session, "Invalid port (must be 1-65535)\n");
            return 0;
        }
        mgmt_config_set_port(g_config_manager, port);
        send_fmt(session, "Pending: port = %d\n", port);

    } else if (strcmp(param, "listen_addr") == 0) {
        mgmt_config_set_listen_addr(g_config_manager, value);
        send_fmt(session, "Pending: listen_addr = %s\n", value);

    } else if (strcmp(param, "connect_addr") == 0) {
        mgmt_config_set_connect_address(g_config_manager, value);
        send_fmt(session, "Pending: connect_addr = %s\n", value);

    } else if (strcmp(param, "mgmt_port") == 0) {
        int port = atoi(value);
        if (port < 0 || port > 65535) {
            send_str(session, "Invalid port (must be 0-65535, 0=disabled)\n");
            return 0;
        }
        mgmt_config_set_mgmt_port(g_config_manager, port);
        send_fmt(session, "Pending: mgmt_port = %d\n", port);

#if TLS_ENABLED
    } else if (strcmp(param, "tls") == 0) {
        int enabled;
        if (strcmp(value, "on") == 0 || strcmp(value, "1") == 0) {
            enabled = 1;
        } else if (strcmp(value, "off") == 0 || strcmp(value, "0") == 0) {
            enabled = 0;
        } else {
            send_fmt(session, "Invalid TLS value: %s (use 'on' or 'off')\n", value);
            return 0;
        }
        mgmt_config_set_tls_enabled(g_config_manager, enabled);
        send_fmt(session, "Pending: tls = %s\n", enabled ? "on" : "off");

    } else if (strcmp(param, "tls_cert") == 0) {
        mgmt_config_set_tls_cert(g_config_manager, value);
        send_fmt(session, "Pending: tls_cert = %s\n", value);

    } else if (strcmp(param, "tls_key") == 0) {
        mgmt_config_set_tls_key(g_config_manager, value);
        send_fmt(session, "Pending: tls_key = %s\n", value);
#endif

    } else {
        send_fmt(session, "Unknown parameter: %s\n", param);
        send_str(session, "Type 'set' for list of parameters\n");
    }

    return 0;
}

/**
 * cmd_get - Get configuration parameter
 */
static int cmd_get(mgmt_session_t *session, int argc, char **argv) {
    const char *param;
    xoe_config_t active;
    xoe_config_t pending;
    int has_pending;

    if (argc < 2) {
        send_str(session, "Usage: get <parameter>\n");
        send_str(session, "Parameters: mode, port, listen_addr, connect_addr, mgmt_port");
#if TLS_ENABLED
        send_str(session, ", tls, tls_cert, tls_key");
#endif
        send_str(session, "\n");
        return 0;
    }

    if (g_config_manager == NULL) {
        send_str(session, "Error: Config manager not initialized\n");
        return 0;
    }

    param = argv[1];
    mgmt_config_get_active(g_config_manager, &active);
    mgmt_config_get_pending(g_config_manager, &pending);
    has_pending = mgmt_config_has_pending(g_config_manager);

    if (strcmp(param, "mode") == 0) {
        const char *active_mode = (active.mode == MODE_SERVER) ? "server" : "client";
        const char *pending_mode = (pending.mode == MODE_SERVER) ? "server" : "client";
        send_fmt(session, "mode: %s", active_mode);
        if (has_pending && active.mode != pending.mode) {
            send_fmt(session, " (pending: %s)", pending_mode);
        }
        send_str(session, "\n");

    } else if (strcmp(param, "port") == 0) {
        send_fmt(session, "port: %d", active.port);
        if (has_pending && active.port != pending.port) {
            send_fmt(session, " (pending: %d)", pending.port);
        }
        send_str(session, "\n");

    } else if (strcmp(param, "listen_addr") == 0) {
        const char *active_addr = active.listen_addr ? active.listen_addr : "0.0.0.0";
        const char *pending_addr = pending.listen_addr ? pending.listen_addr : "0.0.0.0";
        send_fmt(session, "listen_addr: %s", active_addr);
        if (has_pending && strcmp(active_addr, pending_addr) != 0) {
            send_fmt(session, " (pending: %s)", pending_addr);
        }
        send_str(session, "\n");

    } else if (strcmp(param, "connect_addr") == 0) {
        const char *active_addr = active.connect_address ? active.connect_address : "(none)";
        const char *pending_addr = pending.connect_address ? pending.connect_address : "(none)";
        send_fmt(session, "connect_addr: %s", active_addr);
        if (has_pending) {
            int differs = (active.connect_address == NULL && pending.connect_address != NULL) ||
                         (active.connect_address != NULL && pending.connect_address == NULL) ||
                         (active.connect_address != NULL && pending.connect_address != NULL &&
                          strcmp(active.connect_address, pending.connect_address) != 0);
            if (differs) {
                send_fmt(session, " (pending: %s)", pending_addr);
            }
        }
        send_str(session, "\n");

    } else if (strcmp(param, "mgmt_port") == 0) {
        send_fmt(session, "mgmt_port: %d", active.mgmt_port);
        if (has_pending && active.mgmt_port != pending.mgmt_port) {
            send_fmt(session, " (pending: %d)", pending.mgmt_port);
        }
        send_str(session, "\n");

#if TLS_ENABLED
    } else if (strcmp(param, "tls") == 0) {
        send_fmt(session, "tls: %s", active.tls_enabled ? "on" : "off");
        if (has_pending && active.tls_enabled != pending.tls_enabled) {
            send_fmt(session, " (pending: %s)", pending.tls_enabled ? "on" : "off");
        }
        send_str(session, "\n");

    } else if (strcmp(param, "tls_cert") == 0) {
        const char *active_cert = active.tls_cert_path ? active.tls_cert_path : "(none)";
        const char *pending_cert = pending.tls_cert_path ? pending.tls_cert_path : "(none)";
        send_fmt(session, "tls_cert: %s", active_cert);
        if (has_pending) {
            int differs = (active.tls_cert_path == NULL && pending.tls_cert_path != NULL) ||
                         (active.tls_cert_path != NULL && pending.tls_cert_path == NULL) ||
                         (active.tls_cert_path != NULL && pending.tls_cert_path != NULL &&
                          strcmp(active.tls_cert_path, pending.tls_cert_path) != 0);
            if (differs) {
                send_fmt(session, " (pending: %s)", pending_cert);
            }
        }
        send_str(session, "\n");

    } else if (strcmp(param, "tls_key") == 0) {
        const char *active_key = active.tls_key_path ? active.tls_key_path : "(none)";
        const char *pending_key = pending.tls_key_path ? pending.tls_key_path : "(none)";
        send_fmt(session, "tls_key: %s", active_key);
        if (has_pending) {
            int differs = (active.tls_key_path == NULL && pending.tls_key_path != NULL) ||
                         (active.tls_key_path != NULL && pending.tls_key_path == NULL) ||
                         (active.tls_key_path != NULL && pending.tls_key_path != NULL &&
                          strcmp(active.tls_key_path, pending.tls_key_path) != 0);
            if (differs) {
                send_fmt(session, " (pending: %s)", pending_key);
            }
        }
        send_str(session, "\n");
#endif

    } else {
        send_fmt(session, "Unknown parameter: %s\n", param);
        send_str(session, "Type 'get' for list of parameters\n");
    }

    return 0;
}

/**
 * cmd_pending - Show pending changes
 */
static int cmd_pending(mgmt_session_t *session, int argc, char **argv) {
    xoe_config_t active;
    xoe_config_t pending;
    int has_pending;
    int changes = 0;

    (void)argc;
    (void)argv;

    if (g_config_manager == NULL) {
        send_str(session, "Error: Config manager not initialized\n");
        return 0;
    }

    has_pending = mgmt_config_has_pending(g_config_manager);

    if (!has_pending) {
        send_str(session, "No pending changes\n");
        return 0;
    }

    mgmt_config_get_active(g_config_manager, &active);
    mgmt_config_get_pending(g_config_manager, &pending);

    send_str(session, "\n=== Pending Changes ===\n");

    if (active.mode != pending.mode) {
        send_fmt(session, "mode: %s -> %s\n",
                active.mode == MODE_SERVER ? "server" : "client",
                pending.mode == MODE_SERVER ? "server" : "client");
        changes++;
    }

    if (active.port != pending.port) {
        send_fmt(session, "port: %d -> %d\n", active.port, pending.port);
        changes++;
    }

    if ((active.listen_addr == NULL && pending.listen_addr != NULL) ||
        (active.listen_addr != NULL && pending.listen_addr == NULL) ||
        (active.listen_addr != NULL && pending.listen_addr != NULL &&
         strcmp(active.listen_addr, pending.listen_addr) != 0)) {
        send_fmt(session, "listen_addr: %s -> %s\n",
                active.listen_addr ? active.listen_addr : "(null)",
                pending.listen_addr ? pending.listen_addr : "(null)");
        changes++;
    }

    if ((active.connect_address == NULL && pending.connect_address != NULL) ||
        (active.connect_address != NULL && pending.connect_address == NULL) ||
        (active.connect_address != NULL && pending.connect_address != NULL &&
         strcmp(active.connect_address, pending.connect_address) != 0)) {
        send_fmt(session, "connect_addr: %s -> %s\n",
                active.connect_address ? active.connect_address : "(none)",
                pending.connect_address ? pending.connect_address : "(none)");
        changes++;
    }

    if (active.mgmt_port != pending.mgmt_port) {
        send_fmt(session, "mgmt_port: %d -> %d\n", active.mgmt_port, pending.mgmt_port);
        changes++;
    }

#if TLS_ENABLED
    if (active.tls_enabled != pending.tls_enabled) {
        send_fmt(session, "tls: %s -> %s\n",
                active.tls_enabled ? "on" : "off",
                pending.tls_enabled ? "on" : "off");
        changes++;
    }

    if ((active.tls_cert_path == NULL && pending.tls_cert_path != NULL) ||
        (active.tls_cert_path != NULL && pending.tls_cert_path == NULL) ||
        (active.tls_cert_path != NULL && pending.tls_cert_path != NULL &&
         strcmp(active.tls_cert_path, pending.tls_cert_path) != 0)) {
        send_fmt(session, "tls_cert: %s -> %s\n",
                active.tls_cert_path ? active.tls_cert_path : "(none)",
                pending.tls_cert_path ? pending.tls_cert_path : "(none)");
        changes++;
    }

    if ((active.tls_key_path == NULL && pending.tls_key_path != NULL) ||
        (active.tls_key_path != NULL && pending.tls_key_path == NULL) ||
        (active.tls_key_path != NULL && pending.tls_key_path != NULL &&
         strcmp(active.tls_key_path, pending.tls_key_path) != 0)) {
        send_fmt(session, "tls_key: %s -> %s\n",
                active.tls_key_path ? active.tls_key_path : "(none)",
                pending.tls_key_path ? pending.tls_key_path : "(none)");
        changes++;
    }
#endif

    send_fmt(session, "\nTotal: %d change(s)\n", changes);
    send_str(session, "Use 'validate' to check, 'restart' to apply, or 'clear' to discard\n\n");

    return 0;
}

/**
 * cmd_clear - Clear pending changes
 */
static int cmd_clear(mgmt_session_t *session, int argc, char **argv) {
    (void)argc;
    (void)argv;

    if (g_config_manager == NULL) {
        send_str(session, "Error: Config manager not initialized\n");
        return 0;
    }

    if (!mgmt_config_has_pending(g_config_manager)) {
        send_str(session, "No pending changes to clear\n");
        return 0;
    }

    mgmt_config_clear_pending(g_config_manager);
    send_str(session, "Pending changes cleared\n");

    return 0;
}

/**
 * cmd_validate - Validate pending configuration
 */
static int cmd_validate(mgmt_session_t *session, int argc, char **argv) {
    xoe_config_t pending;
    const char *error_msg;

    (void)argc;
    (void)argv;

    if (g_config_manager == NULL) {
        send_str(session, "Error: Config manager not initialized\n");
        return 0;
    }

    if (!mgmt_config_has_pending(g_config_manager)) {
        send_str(session, "No pending changes to validate\n");
        return 0;
    }

    mgmt_config_get_pending(g_config_manager, &pending);

    /* Validate pending configuration */
    error_msg = mgmt_config_validate(g_config_manager, &pending);
    if (error_msg != NULL) {
        send_fmt(session, "Validation failed: %s\n", error_msg);
        return 0;
    }

    send_str(session, "Validation passed - configuration is valid\n");
    send_str(session, "Use 'restart' to apply changes\n");

    return 0;
}

/**
 * cmd_restart - Apply changes and restart
 */
static int cmd_restart(mgmt_session_t *session, int argc, char **argv) {
    const char *error_msg;
    xoe_config_t pending;

    (void)argc;
    (void)argv;

    if (g_config_manager == NULL) {
        send_str(session, "Error: Config manager not initialized\n");
        return 0;
    }

    /* Check if there are pending changes */
    if (!mgmt_config_has_pending(g_config_manager)) {
        send_str(session, "No pending changes - nothing to apply\n");
        send_str(session, "Use 'set' to modify configuration\n");
        return 0;
    }

    /* Validate pending config before triggering restart */
    mgmt_config_get_pending(g_config_manager, &pending);
    error_msg = mgmt_config_validate(g_config_manager, &pending);
    if (error_msg != NULL) {
        send_fmt(session, "Cannot restart - validation failed: %s\n", error_msg);
        send_str(session, "Fix configuration errors and try again\n");
        return 0;
    }

    /* Trigger restart */
    g_mgmt_restart_requested = 1;

    send_str(session, "\nRestart initiated:\n");
    send_str(session, "  1. Disconnecting all clients...\n");
    send_str(session, "  2. Stopping current mode...\n");
    send_str(session, "  3. Applying new configuration...\n");
    send_str(session, "  4. Restarting with new settings...\n\n");
    send_str(session, "Management session will remain active\n");

    return 0;
}

/**
 * cmd_quit - Close session
 */
static int cmd_quit(mgmt_session_t *session, int argc, char **argv) {
    (void)argc;
    (void)argv;

    send_str(session, "Goodbye\n");

    return 1;  /* Signal exit */
}

/**
 * cmd_shutdown - Shutdown application
 */
static int cmd_shutdown(mgmt_session_t *session, int argc, char **argv) {
    (void)argc;
    (void)argv;

    send_str(session, "TODO: Trigger application shutdown (Phase 6)\n");
    send_str(session, "Would transition to STATE_CLEANUP\n");

    return 0;
}
